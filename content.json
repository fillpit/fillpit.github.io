{"pages":[{"title":"","text":"关于我泰戈尔说过，只有经历地狱般的磨炼，才能炼出创造天堂的力量；只有流过血的手指，才能弹出世间的绝唱。梦想是世间的绝唱，只有不甘于现状的挣扎才能不断演奏出不平凡的乐章。 当一个人无法甘于平凡，就会让自己特别。不是特别好，就是特别差，结果取决于你自己。 保持一颗平常心 心怀梦想,永远向前 找到牛人,共同进步 丢掉那些自己给自己所谓的束缚,没有你做不到的,超越自己 抛弃建议,寻找事实 真正的大师永远,怀着一颗学徒的心","link":"/about/index.html"}],"posts":[{"title":"Java 多线程中 Thread、Runnable 和 FutureTask 比较","text":"1. 用 Thread 创建一个线程1234567891011121314151617public class ThreadTest { public static class MyThread extends Thread { @Override public void run() { Thread.sleep(100); System.out.println(&quot;Hello world&quot;); } } public static void main(String[] args) { // 创建线程 MyThread myThread = new MyThread(); // 启动线程 myThread.start(); System.out.println(&quot;Main&quot;); }} 可以直接使用 this 获取当前线程 Java 不支持多继承, 如果继承了 Thread 就不能继承其他类了 任务与代码没有分离, 如果多个线程执行一样的任务时需要多份任务代码 没有返回值 2. 用 Runnable 创建一个线程12345678910111213141516public class RunAbleTask implements Runnable { @Override public void run() { Thread.sleep(100); System.out.println(&quot;Hello World&quot;); } public static void main(String[] args) { // 创建任务 RunAbleTask runAbleTask = new RunAbleTask(); // 启动任务 new Thread(runAbleTask).start(); new Thread(runAbleTask).start(); System.out.println(&quot;Main&quot;); }} 多个线程可以共享一份 task 代码逻辑 RunAbleTask 可以继承其他类 没有返回值 3. 用 FutureTask 创建一个线程123456789101112131415161718192021222324public class CallerTask implements Callable&lt;String&gt; { @Override public String call() throws Exception { Thread.sleep(100); return &quot;Hello World&quot;; } public static void main(String[] args) { // 创建异步任务// FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(() -&gt; &quot;Hello World&quot;); FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(new CallerTask()); // 启动多线程 new Thread(futureTask).start(); // 等待任务执行完毕 String result = null; try { result = futureTask.get(); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } System.out.println(result); System.out.println(&quot;Main&quot;); }} 多个线程可以共享一份 task 代码逻辑 FutureTask 可以继承其他类 有返回值 主线程会堵塞 总结 特性 Thread Runable FutureTask 是否能继承其他类 不能 能 能 共享任务代码 不能 能 能 有返回值 没有 没有 有 会堵塞主线程 不会 不会 会","link":"/2019/12/01/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD-Thread%E3%80%81Runnable-%E5%92%8C-FutureTask-%E6%AF%94%E8%BE%83/"},{"title":"Jenkins 修改为中文显示","text":"Jenkins 的界面语言默认是英文的，但Jenkins 提供了中午插件，可以下载中午插件来修改界面语 进入Jenkins 的插件界面 搜索 local , 下载 local 和 localization-zh-cn 插件 2. 重启 Jenkins (安装插件时就可以选择重启，也可以手动重启 Jenkins) 3. 进入系统管理Manage Jenkins &gt; Configure System，找到 Locale 配置，设置为 zh_cn 4. 刷新浏览器界面就变成中文的了。但是还是只是部分中文。","link":"/2020/08/05/Jenkins-%E4%BF%AE%E6%94%B9%E4%B8%BA%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA/"},{"title":"Jenkins 配置邮件发送服务","text":"Jenkins每次执行完了之后都要登陆到页面上去看是否重建成功没，相当麻烦，配置好邮件通知服务在Jenkins建立完后会自动发送邮件通知相关人员，再也不用为建造失败而担心受怕了 一。下载插件：管理詹金斯-&gt;管理插件-&gt;可用搜索电子邮件扩展插件插件初始化安装 二。设置插件：管理詹金斯-&gt;配置系统 配置管理员的邮件地址先配置一下管理员的邮件地址，此地址必须与邮件的发送帐户一致 配置发送服务器配置邮件的发送服务器和内容类型 设置邮件发送方的用户名密码 配置预设收件人 配置邮件主题和模版 配置发送邮件的默认触发方式 里配置配置里，找到后期生成操作编辑电子邮件通知添加一个构建完成后发送邮件 设置收件人地址 设置邮件的发送目标 设置好后保存，打造成功后能够收到内置成功的邮件了 ps：附上邮件模版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;${ENV, var=&quot;JOB_NAME&quot;}-第${BUILD_NUMBER}次构建日志&lt;/title&gt; &lt;/head&gt; &lt;body leftmargin=&quot;8&quot; marginwidth=&quot;0&quot; topmargin=&quot;8&quot; marginheight=&quot;4&quot; offset=&quot;0&quot;&gt; &lt;table width=&quot;95%&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; style=&quot;font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif&quot;&gt; &lt;tr&gt; 本邮件由系统自动发出，无需回复！&lt;br/&gt; 各位同事，大家好，以下为${PROJECT_NAME }项目构建信息&lt;/br&gt; &lt;td&gt;&lt;font color=&quot;#CC0000&quot;&gt;构建结果 - ${BUILD_STATUS}&lt;/font&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;br /&gt; &lt;b&gt;&lt;font color=&quot;#0B610B&quot;&gt;构建信息&lt;/font&gt;&lt;/b&gt; &lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;ul&gt; &lt;li&gt;项目名称 ： ${PROJECT_NAME}&lt;/li&gt; &lt;li&gt;构建编号 ： 第${BUILD_NUMBER}次构建&lt;/li&gt; &lt;li&gt;触发原因： ${CAUSE}&lt;/li&gt; &lt;li&gt;构建状态： ${BUILD_STATUS}&lt;/li&gt; &lt;li&gt;构建日志： &lt;a href=&quot;${BUILD_URL}console&quot;&gt;${BUILD_URL}console&lt;/a&gt;&lt;/li&gt; &lt;li&gt;构建 Url ： &lt;a href=&quot;${BUILD_URL}&quot;&gt;${BUILD_URL}&lt;/a&gt;&lt;/li&gt; &lt;li&gt;工作目录 ： &lt;a href=&quot;${PROJECT_URL}ws&quot;&gt;${PROJECT_URL}ws&lt;/a&gt;&lt;/li&gt; &lt;li&gt;项目 Url ： &lt;a href=&quot;${PROJECT_URL}&quot;&gt;${PROJECT_URL}&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;&lt;font color=&quot;#0B610B&quot;&gt;失败用例&lt;/font&gt;&lt;/h4&gt; &lt;hr size=&quot;2&quot; width=&quot;100%&quot; /&gt; $FAILED_TESTS&lt;br/&gt; &lt;h4&gt;&lt;font color=&quot;#0B610B&quot;&gt;最近提交(#$SVN_REVISION)&lt;/font&gt;&lt;/h4&gt; &lt;hr size=&quot;2&quot; width=&quot;100%&quot; /&gt; &lt;ul&gt; ${CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=&quot;%c&quot;, changesFormat=&quot;&lt;li&gt;%d [%a] %m&lt;/li&gt;&quot;} &lt;/ul&gt; 详细提交: &lt;a href=&quot;${PROJECT_URL}changes&quot;&gt;${PROJECT_URL}changes&lt;/a&gt;&lt;br/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 注意事项问题一： 英文那接收目标默认设置的的英文开发人员空白向收件人列表发送电子邮件的尝试忽略被","link":"/2020/07/03/Jenkins-%E9%85%8D%E7%BD%AE%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E6%9C%8D%E5%8A%A1/"},{"title":"Mac 环境下使用 NVM 管理多版本的 NodeJs","text":"有时我们需要安装多个版本的nodejs，安装可能不是什么难事, 但多个 node 的版本的切换就非常让人头疼，这个时候就轮到 nvm 出场了, 使用 nvm可以让你方便快捷地切换node版本. 安装安装之前先检查当前用户的用户目录下是否存在以下文件 ~ .bash_profile 没有的话就先创建, 安装脚本的时候会自动帮我们把环境变量写进该文件,当然你软件安装完后发现没这个文件的话只需要自行把以下代码写入到该文件内也是一样的效果 123export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion 好了准备工作完成后我们就可以运行下面的脚本来 下载 或 更新 nvm 1curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash 注意: 如果你安装了 oh my zsh, 需要在 .zshrc 文件去添加以下配置信息 123export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion 否则你运行 nvm -v 可能会遇到以下提示 nvm: command not found nvm 常用命令列出所有安装的版本 nvm ls 显示当前使用的版本 nvm current 列出官网上node的所有版本 nvm ls-remote 安装最新稳定版 node nvm install stable 安装指定版本 nvm install 切换使用指定的版本node nvm use 指定默认版本 nvm alias default nvm 卸载先运行以下命令删除下载文件 1rm -rf &quot;$NVM_DIR&quot; 然后再编辑 ~ .bash_profile 和 ~ .zshrc 文件删除其环境变量 123export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion 总结以上方法都是我亲自试过的, 如果你按照教程安装后还是有问题 应该先核对一下版本是否有问题, 当然你也可以去 官方仓库 看看最新的版本和安装方法","link":"/2019/08/01/Mac-%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8-NVM-%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%AC%E7%9A%84-NodeJs/"},{"title":"MAC、iPhone 使用自带的邮件客户端登陆阿里邮箱","text":"阿里云邮箱除了网页版还可以使用第三方的工具如OUTlook,foxmail等，原理都一样的, 这里给大家操作一下使用自带的客户端登录邮箱。 在 Mac 上登录一. 点击 邮件 -&gt; 账户 二. 选择其它账户, 点击继续 三. 填上用户名、密码, 点击登录 四. 接着会弹出以下界面, 输入 收/发件服务器 后点击登录就能登录成功了 ps:收件服务器: imap.aliyun.com \\ pop3.aliyun.com发件服务器: smtp.aliyun.com iPhone 上登录一. 输入 用户名、密码 后点击下一步 二. 填上收/发件服务器 和用户名密码后点击下一步, 稍等片刻后就会进入邮箱的主界面了服务器类型地址用户名密码 收件服务器imap.aliyun.com完整的邮箱账号如test@aliyun.com邮箱登录密码发件服务器smtp.aliyun.com完整的邮箱账号如test@aliyun.com邮箱登录密码 PS：如您需要使用SSL加密协议，请对应将服务器端口更改为：POP3：995 IMAP：993 SMTP：465","link":"/2020/06/28/MAC%E3%80%81iPhone-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B8%A6%E7%9A%84%E9%82%AE%E4%BB%B6%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%99%BB%E9%99%86%E9%98%BF%E9%87%8C%E9%82%AE%E7%AE%B1/"},{"title":"Spring boot 打 war 包","text":"第一步在启动类的同级目录下新建一个 ServletInitializer.java 1234567public class ServletInitializer extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) { // DemoApplication.class 是启动类 return application.sources(DemoApplication.class); }} 第二步修改 maven 的打包方式为 war 1&lt;packaging&gt;war&lt;/packaging&gt; 小节看网上很多教程要加入 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 但我测试的时候不加入也能打包, 用 tomcat 也能运行和访问,所以教程里就没写这个了","link":"/2019/06/28/Spring-boot-%E6%89%93-war-%E5%8C%85/"},{"title":"Raspberry pi 4b 安装 docker","text":"下载安装脚本进行安装 1curl -fsSL https://get.docker.com -o get-docker.sh &amp;&amp; sudo sh get-docker.sh 稍等一会就会输出docker 的安装信息，自此 docker 已经安装完成了 安装后我们可以输入 `docker images` 看看docker 有没有安装成功， 输入后会屏幕会打印出以下错误 Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 那是因为docker 默认是在 root 用户下运行的，如果想在非 root 用户下操作, 可以把用户添加到 docker 组中 1sudo usermod -aG docker your-user 执行完后必须得注销重新登陆才会生效 易用设置安装后我们还可以设置 docker 开机自启 1sudo systemctl enable docker 还可以设置 docker 的镜像源, 更改镜像源我们需要编辑 sudo nano /etc/docker/daemon.json 文件, 输入以下源 123456789{ &quot;registry-mirrors&quot;:[ &quot;https://reg-mirror.qiniu.com/&quot;, &quot;https://hub-mirror.c.163.com/&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot;, &quot;https://dockerhub.azk8s.cn&quot;, &quot;http://f1361db2.m.daocloud.io&quot; ]} 修改源后需要重启 docker 才会生效 12sudo systemctl daemon-reload sudo systemctl restart docker 如果你想要卸载 docker 可以执行 1sudo apt-get purge docker-ce docker-ce-cli containerd.io 但这样并不会删除主机上的 镜像，容器，卷或自定义配置文件。如果不想保留的话可以执行 1sudo rm -rf /var/lib/docker 详细的安装方法请查看 官方文档","link":"/2020/07/31/Raspberry-pi-4b-%E5%AE%89%E8%A3%85-docker/"},{"title":"Raspberry pi 4B 修改系统默认为Python3","text":"如果没有修改的话系统默认是python2 的, 可以输入 python -V 进行查看 进入 /usr/bin 目录下输入 ls -all | grep python 命令我们可以看到系统默认是指向python2 的，我们只需要修改一下软链接的指向就可以了 先删除python2的软链接 1sudo rm python 再创建指向 python3 的软链接 再次查看版本号可以看到已经被我们修改成python3 了","link":"/2021/06/17/Raspberry-pi-4B-%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4%E4%B8%BAPython3/"},{"title":"Unraid 借助 rclone 备份数据到 阿里云盘","text":"狡兔三窟, 备份数据到 阿里云盘 前言nas 虽好, 但总有硬盘损毁的时候, 所以备份数据是个好习惯, 阿里云盘容量大还不限速, 所以是个不错的选择, 但官方可没提供这样的功能, 所以我们要借助 webdav-aliyundriver 这个项目为 阿里云盘 开启 webdav, 再用 rclone 来同步本地要备份的数据到 阿里云盘上 准备工作先为 阿里云盘 开启 webdav 协议, 可以到这里找到 https://blog.fillpit.cn/kai-qi-a-li-yun-pan-de-web-dav-zhi-chi-s/ 下载插件登录 unraid 的管理界面, 点击 应用 -&gt; 搜索 rclone -&gt; 安装插件 再下载 User Scripts 插件 配置 rclone打开unraid 的控制台, 输入 rclone config 测试配置是否正常输入 rclone ls remote: 列出 WebDAV 中的所有文件 同步文件我这里用 appdata 目录来做演示 1rclone sync /mnt/user/appdata Alibaba-webdev:unraid_appdata/ rclone sync – 同步命令 /mnt/user/appdata – 要同步的本地目录 Alibaba-webdev:unraid_appdata/ – 上传到 Alibaba-webdev 服务的 unraid_appdata 目录下 定时执行同步点击 设置 -&gt; User Scripts 附: rclone 常用命令123456789101112131415161718rclone config - 以控制会话的形式添加rclone的配置，配置保存在.rclone.conf文件中。rclone copy - 将文件从源复制到目的地址，跳过已复制完成的。rclone sync - 将源数据同步到目的地址，只更新目的地址的数据。rclone move - 将源数据移动到目的地址。rclone delete - 删除指定路径下的文件内容。rclone purge - 清空指定路径下所有文件数据。rclone mkdir - 创建一个新目录。rclone rmdir - 删除空目录。rclone check - 检查源和目的地址数据是否匹配。rclone ls - 列出指定路径下所有的文件以及文件大小和路径。rclone lsd - 列出指定路径下所有的目录/容器/桶。rclone lsl - 列出指定路径下所有文件以及修改时间、文件大小和路径。rclone md5sum - 为指定路径下的所有文件产生一个md5sum文件。rclone sha1sum - 为指定路径下的所有文件产生一个sha1sum文件。rclone size - 获取指定路径下，文件内容的总大小。.rclone version - 查看当前版本。rclone cleanup - 清空remote。rclone dedupe - 交互式查找重复文件，进行删除/重命名操作。","link":"/2021/08/04/Unraid-%E5%80%9F%E5%8A%A9-rclone-%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%88%B0-%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/"},{"title":"开启Chrome多线程下载","text":"告别龟速下载 在地址栏输入并回车：chrome://flags/#enable-parallel-downloading 视图会自动帮你定位到这一行, 点击右边的选项列表选择 Enabled 点击底部的Relaunch重启浏览器 下载速度提升了 3 倍","link":"/2021/05/09/%E5%BC%80%E5%90%AFChrome%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD/"},{"title":"开启阿里云盘的 Web DAV 支持, 设置本地挂载","text":"把不限速的 阿里云盘 挂载到电脑上当本地硬盘使用 前言把不限速的 阿里云盘 挂载到电脑上当本地硬盘使用, 但 阿里云盘 并不支持这个功能, 借助 webdav-aliyundriver 这个项目, 我们可以为 阿里云盘 开启 webdav 协议来支持本地硬盘挂载 准备工作首先你得有个阿里云盘的账号, 没有的话就先去注册一个 官方链接 邀请链接, 注册可得500G 运行 dacker 容器1234567891011docker run -d \\ --name=webdav-aliyundriver \\ --restart=always \\ -p 8080:8080 \\ -v /etc/localtime:/etc/localtime \\ -v /etc/aliyun-driver/:/etc/aliyun-driver/ \\ -e TZ=&quot;Asia/Shanghai&quot; \\ -e ALIYUNDRIVE_REFRESH_TOKEN=&quot;your refreshToken&quot; \\ -e ALIYUNDRIVE_AUTH_PASSWORD=&quot;admin&quot; \\ -e JAVA_OPTS=&quot;-Xmx1g&quot; \\ zx5253/webdav-aliyundriver docker-compose.yml 123456789101112131415161718version: '3'services: webdav-aliyundriver: image: zx5253/webdav-aliyundriver container_name: webdav-aliyundriver restart: always volumes: - /etc/localtime:/etc/localtime - $PWD/aliyun-driver/:/etc/aliyun-driver/ ports: - &quot;8080:8080&quot; environment: - TZ=Asia/Shanghai - JAVA_OPTS=-Xmx1g # 最大内存占用, 限制为1G - ALIYUNDRIVE_REFRESH_TOKEN=token # 阿里云盘的token, 下面有获取方式 - ALIYUNDRIVE_AUTH_USER_NAME=用户名 # WebDav账户,不是阿里云的账号 - ALIYUNDRIVE_AUTH_PASSWORD=密码 # WebDav密码,不是阿里云的密码 浏览器获取refreshToken方式 先通过浏览器（建议chrome）打开 阿里云盘官网并登录 登录成功后，按 F12 打开开发者工具，点击 Application -&gt; Local Storage -&gt; https://www.aliyundrive.com/ -&gt; token，此时可以看到里面的数据，其中就有refresh_token，把其值复制出来即可。（格式为小写字母和数字，不要复制双引号。例子：ca6bf2175d73as2188efg81f87e55f11） 测试服务是正常使用支持webdav的系统或软件来挂载阿里云盘webdav, 可以先在浏览器中测试服务是否正常 Mac 挂载 WebDAV 服务器 在 Mac 上的“访达” 中，选取“前往”&gt;“连接服务器”，在“服务器地址”栏中输入服务器的地址，然后点按“连接”。 在“服务器地址”栏中输入服务器的地址。WebDAV 服务器地址应该与以下的格式类似：http://servername.com/path/ 点按“连接” 后会弹出框输入用户名密码后即可 客户端兼容性客户端 下载 上传 备注 群辉Cloud Sync 可用 可用 使用单向同步非常稳定 Rclone 可用 可用 推荐，支持各个系统 Mac原生 可用 可用 Windows原生 可用 有点小问题 不建议，适配有点问题，上传报错 RaiDrive 可用 可用 Windows平台下建议用这个","link":"/2021/08/04/%E5%BC%80%E5%90%AF%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E7%9A%84-Web-DAV-%E6%94%AF%E6%8C%81-%E8%AE%BE%E7%BD%AE%E6%9C%AC%E5%9C%B0%E6%8C%82%E8%BD%BD/"},{"title":"用 Docker 搭建 frps 内网穿透服务","text":"frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp 协议，为 http 和 https 应用协议提供了额外的能力，且尝试性支持了点对点穿透。 虽然现在宽带速度都很快，但对于电脑玩家来说，最大的问题是“没有公网 IP”！这使得想要在外访问家里的电脑、NAS、树莓派、摄像头等网络设备或远程控制等，都无法轻松实现。 这时你就需要一款内网穿透工具来让外网与你家内网建立起连接，实现无公网 IP 的远程访问了。「Frp」是一款流行的跨平台开源免费内网穿透工具，支持 Windows、macOS 与 Linux。你只需一台快速稳定的 VPS 服务器即可愉快地进行内网穿透，实现家中设备公网直接访问了…… 部署自从学会了docker,我就在搭建各种环境的时候就有了_洁癖_:服务器上的各种软件,必须使用docker来搭建. 去hub.docker.com上搜了一下,有现成的服务端( snowdreamtech/frps) 和客户端(snowdreamtech/frpc),但这次我只需要服务端就好了，如果你的 openwrt 固件上没有安装frpc 客户端，你可以在这里下载( kuoruan/openwrt-frp 和 kuoruan/luci-app-frpc) 启动服务端先创建服务端的配置文件`frps.ini` (完整的服务端配置) 1234567891011121314151617181920212223242526272829[common]# 绑定远程主机端口bind_port = 17000# 开启 token 验证token = P.3cqN4vr4g9oPRvN.PB# http 和 https 的访问端口# http端口和https端口可以与bind_port相同vhost_http_port = 10080# vhost_https_port = 10443# 监控面板端口 # 注：Dashboard 尚未针对大量的 proxy 数据展示做优化，如果出现 Dashboard 访问较慢的情况，请不要启用此功能。dashboard_port = 17500dashboard_user = admindashboard_pwd = admin # TCP 多路复用# 从 v0.10.0 版本开始，客户端和服务器端之间的连接支持多路复用，不再需要为每一个用户请# # 求创建一个连接，使连接建立的延迟降低，并且避免了大量文件描述符的占用，使 frp 可以承载# 更高的并发数。tcp_mux = true# 连接池max_pool_count = 10# 自定义二级域名# 只需要将 *.{subdomain_host} 解析到 frps 所在服务器。之后用户可以通过 subdomain # 行指定自己的 web 服务所需要使用的二级域名，通过 {subdomain}.{subdomain_host} 来访# 问自己的 web 服务。subdomain_host = fillpit.top 创建 docker-compose.yml 文件1234567891011121314version: '3'services: frps: image: snowdreamtech/frps container_name: frps ports: - &quot;17000:17000&quot; - &quot;17500:17500&quot; - &quot;10080:10080&quot; - &quot;10010-10020&quot;:&quot;10010-10020&quot; # 映射其他端口 volumes: - $PWD/conf/frps.ini:/etc/frp/frps.ini restart: always 执行 `docker stack deploy myfrps -c=docker-compose.yml` 创建客户端配置 frpc.ini123456789101112131415161718192021222324252627# frpc.ini[common]# 服务器地址 和 端口server_addr = x.x.x.xserver_port = 7000[web]# 连接类型，填 http 或 httpstype = http# 本地web服务访问地址 和端口local_ip = 127.0.0.1local_port = 80# 开启 加密与压缩use_encryption = trueuse_compression = true# 客户端的访问子域名，搭配服务端的 [subdomain_host] 使用# 通过 test.frps.com 就可以访问到内网的 web 服务。subdomain = test# 通过密码保护你的 web 服务# 由于所有客户端共用一个 frps 的 http 服务端口，任何知道你的域名和 url 的人都能访问到# 你部署在内网的 web 服务，但是在某些场景下需要确保只有限定的用户才能访问。http_user = abchttp_pwd = abc","link":"/2021/06/17/%E7%94%A8-Docker-%E6%90%AD%E5%BB%BA-frps-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%9C%8D%E5%8A%A1/"},{"title":"使用 GitHub Actions 实现 Hexo 博客自动部署","text":"hexo 本身就支持快捷部署的命令, 不过每次都要执行 hexo d 这个命令, 而且还要确保本地环境没有问题, 一旦换个环境又得重新配置,实属麻烦, 我们的原则是能躺着决不坐着, 加上GitHub Actions 又是免费的, 不用白不用 工作原理 hexo 的源工程文件单独建立一个私有仓库 每次提交完代码后触发构建 让 GitHub Actions 帮我们自动执行 hexo d 命令 准备工作 首先确保你已经创建了保存工程源代码的仓库 和 GitHub Page 仓库 确定你在本地执行 hexo d 可以正常部署 生成 ssh keyssh key 的作用是保证可以不用登陆也可以正常的 提交/拉去 代码, 因为把 用户名和密码暴露在网上是不安全的 1ssh-keygen -t rsa -b 4096 -C &quot;$(git config user.email)&quot; -f hexo-deploy-key -N &quot;&quot; 在当前目录下生成文件: * hexo-deploy-key # 私钥文件 * hexo-deploy-key.pub # 公钥文件 切记不要把这两个文件上传到仓库里, 避免泄露 在源代码仓库添加 私钥在仓库页面依次点击 Settings -&gt; Secrets -&gt; new repository secrets, 如下图 key 设置为 HEXO_DEPLOY_KEY, 当然你也可以自取, 那后面也要跟着改 示例12345-----BEGIN OPENSSH PRIVATE KEY-----b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn.......vgpvENPs0nbwDfAAAAEWtlbmZlaUBhbGl5dW4uY29tAQ==-----END OPENSSH PRIVATE KEY----- 在 GitHub Pages 页添加公钥在仓库页面依次点击 Settings -&gt; Deploye keys -&gt; Add deploy key, 如下图 key 可以自己取, 自己认识就行, 没有影响, 这里默认就用 hexo-deploy-keys 示例1ssh-rsa AAAAB3Nza6pD .... ZYIVYIDyOFNmtjBZVyAXK+rKKYeC3U= xxx@aliyun.com 编写 workflows 文件在 源代码工程目录下创建流程文件 .github/workflows/deploy.yml 12345678910111213141516171819202122232425262728293031323334353637383940name: Deploy # workflow nameon: [push] # 触发事件jobs: build: # job1 id runs-on: ubuntu-latest name: A job to deploy blog. steps: # 获取源码 - name: Checkout uses: actions/checkout@v1 with: # 签出私有子模块(主题或其他内容) submodules: true # 缓存压缩 node_modules，不用每次下载，使用时解压，可以加快工作流的执行过程，超过 7 天没有使用将删除压缩包。 - name: Cache node modules uses: actions/cache@v1 id: cache with: path: node_modules key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }} restore-keys: | ${{ runner.os }}-node- # 安装依赖 - name: Install Dependencies if: steps.cache.outputs.cache-hit != 'true' run: npm install # 部署 hexo 博客网站. - name: Deploy id: deploy uses: sma11black/hexo-action@v1.0.0 with: deploy_key: ${{ secrets.HEXO_DEPLOY_KEY }} user_name: your github username user_email: your github useremail 注意: 里面有两个需要配置的地方user_name: 你 github 的用户名(举例: 在 https://github.com/fillpit/xxxx 中 fillpit 就是用户名)user_email: 你 github 的注册邮箱 Hexo 配置查看项目根目录中 _config.yml 文件的部署相关内容： 1234deploy: type: git repo: git@github.com:fillpit/fillpit.github.io.git branch: main 这里的repo要填写ssh的形式，千万不要使用http形式 验证现在 Hexo 已经和 GitHub Actions 已经集成了，接下来在博客源码分支上推送代码即可自动编译部署。具体执行过程可以在 Actions 中查看： 事故现场出现 could not read Username for ‘https://github.com': No such device or address 解决方案: 查看 _config.yml 中的 deploy.repo 字段是不是用了 http 形式的链接, 如果是就 改成 ssh 形式的, 具体配置查看上面的 Hexo 配置","link":"/2021/09/06/%E4%BD%BF%E7%94%A8%20GitHub%20Actions%20%E5%AE%9E%E7%8E%B0%20Hexo%20%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"title":"Colly 入门实战","text":"成果展示先看结果, 这是要爬的页面 这是结果 安装 Colly1go get -u github.com/gocolly/colly/... 简单例子12345678910111213141516func main() { c := colly.NewCollector() // 找到并访问所有链接 c.OnHTML(&quot;a[href]&quot;, func(e *colly.HTMLElement) { e.Request.Visit(e.Attr(&quot;href&quot;)) }) // 打印请求的链接 c.OnRequest(func(r *colly.Request) { fmt.Println(&quot;Visiting&quot;, r.URL) }) // 发送 get 请求 c.Visit(&quot;http://go-colly.org/&quot;)} 全部有哪些回调方法12345678910111213141516171819202122232425262728293031c.OnRequest(func(r *colly.Request) { fmt.Println(&quot;Visiting&quot;, r.URL)})c.OnError(func(_ *colly.Response, err error) { log.Println(&quot;Something went wrong:&quot;, err)})c.OnResponseHeaders(func(r *colly.Response) { fmt.Println(&quot;Visited&quot;, r.Request.URL)})c.OnResponse(func(r *colly.Response) { fmt.Println(&quot;Visited&quot;, r.Request.URL)})c.OnHTML(&quot;a[href]&quot;, func(e *colly.HTMLElement) { e.Request.Visit(e.Attr(&quot;href&quot;))})c.OnHTML(&quot;tr td:nth-of-type(1)&quot;, func(e *colly.HTMLElement) { fmt.Println(&quot;First column of a table row:&quot;, e.Text)})c.OnXML(&quot;//h1&quot;, func(e *colly.XMLElement) { fmt.Println(e.Text)})c.OnScraped(func(r *colly.Response) { fmt.Println(&quot;Finished&quot;, r.Request.URL)}) 调用顺序1.OnRequest在请求之前调用 2.OnError如果请求期间发生错误,则调用 3.OnResponseHeaders在收到响应标头后调用 4.OnResponse收到回复后调用 5.OnHTMLOnResponse如果收到的内容是HTML ,则在之后调用 6.OnXMLOnHTML如果接收到的内容是HTML或XML ,则在之后调用 7.OnScrapedOnXML回调后调用 实战这是地址页 地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132package mainimport ( zipUtils &quot;Spider/utils&quot; &quot;bytes&quot; &quot;fmt&quot; &quot;io&quot; &quot;io/ioutil&quot; &quot;os&quot; &quot;path&quot; &quot;regexp&quot; &quot;strconv&quot; &quot;strings&quot; &quot;github.com/gocolly/colly&quot;)func main() { temp := &quot;./out/temp&quot; chapter := temp zipDir := &quot;./out/zip&quot; zipFile := &quot;x.zip&quot; bookId := &quot;25797&quot; bookHome := &quot;https://www.manhuadb.com/manhua/&quot; + bookId // Instantiate default collector c := colly.NewCollector() // Before making a request print &quot;Visiting ...&quot; c.OnRequest(func(r *colly.Request) { fmt.Println(&quot;Visiting&quot;, r.URL.String()) }) c.OnRequest(func(rq *colly.Request) { rq.Headers.Add(&quot;Accept&quot;, &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;) rq.Headers.Add(&quot;Accept-Encoding&quot;, &quot;gzip, deflate&quot;) rq.Headers.Add(&quot;Accept-Language&quot;, &quot;zh,en-US;q=0.9,en;q=0.8,zh-TW;q=0.7,zh-CN;q=0.6&quot;) rq.Headers.Add(&quot;Cache-Control&quot;, &quot;no-cache&quot;) rq.Headers.Add(&quot;Connection&quot;, &quot;keep-alive&quot;) rq.Headers.Add(&quot;Host&quot;, &quot;www.manhuadb.com&quot;) rq.Headers.Add(&quot;Pragma&quot;, &quot;no-cache&quot;) rq.Headers.Add(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36&quot;) }) c.OnResponse(func(r *colly.Response) { //fmt.Println(string(r.Body)) if strings.Contains(r.Headers.Get(&quot;content-type&quot;), &quot;image&quot;) { fileName := path.Base(r.Request.URL.String()) f, err := os.Create(chapter + &quot;/&quot; + fileName) if err != nil { panic(err) } io.Copy(f, bytes.NewReader(r.Body)) } }) // 标题 c.OnHTML(&quot;h1[class=\\&quot;comic-title\\&quot;]&quot;, func(e *colly.HTMLElement) { fmt.Printf(&quot;返回值: %s \\n&quot;, e.Text) text := strings.Replace(e.Text, &quot; &quot;, &quot;&quot;, -1) // 去 空格 text = strings.Replace(e.Text, &quot;?&quot;, &quot;&quot;, -1) // 去 ？ temp = temp + &quot;/&quot; + text os.MkdirAll(temp, 0711) zipDir = zipDir + &quot;/&quot; + text os.MkdirAll(zipDir, 0711) }) // 章节列表 c.OnHTML(&quot;li[class=\\&quot;sort_div fixed-wd-num\\&quot;] &gt; a&quot;, func(e *colly.HTMLElement) { chapterTitle := e.Attr(&quot;title&quot;) if chapterTitle != &quot;&quot; { println(&quot;章节==：&quot;, chapterTitle) url := e.Attr(&quot;href&quot;) chapter = temp + &quot;/&quot; + chapterTitle os.MkdirAll(chapter, 0711) chapterUrl := &quot;https://www.manhuadb.com&quot; + url c.Visit(chapterUrl) } }) // img 列表 c.OnHTML(&quot;div[class=\\&quot;text-center pjax-container\\&quot;] &gt; img&quot;, func(e *colly.HTMLElement) { imgUrl := e.Attr(&quot;src&quot;) if imgUrl != &quot;&quot; { c.Visit(imgUrl) } }) // 判断是否还有下一页 c.OnHTML(&quot;div[class=\\&quot;container-fluid comic-detail p-0\\&quot;]&quot;, func(e *colly.HTMLElement) { pageHref := e.ChildAttr(&quot;li[class=\\&quot;breadcrumb-item active\\&quot;] &gt; a&quot;, &quot;href&quot;) currentPage := e.ChildText(&quot;li[class=\\&quot;breadcrumb-item active\\&quot;] &gt; span&quot;) reg := regexp.MustCompile(&quot;共 ([0-9]*?) 页&quot;) sumPageSize := reg.FindStringSubmatch(e.ChildText(&quot;li[class=\\&quot;breadcrumb-item active\\&quot;]&quot;)) hrefs := strings.Split(pageHref, &quot;.&quot;) sumPageSizeNum, err:=strconv.Atoi(sumPageSize[1]) currentPageNum, err:=strconv.Atoi(currentPage) if err != nil { println(err) } if currentPageNum &lt; sumPageSizeNum { p :=strconv.Itoa(currentPageNum + 1) next := &quot;https://www.manhuadb.com&quot; + hrefs[0] + &quot;_p&quot;+ p +&quot;.&quot; + hrefs[1] c.Visit(next) } }) // Start scraping on https://hackerspaces.org c.Visit(bookHome) // 压缩 items, _ := ioutil.ReadDir(temp) for _, item := range items { if item.IsDir() { src := temp + &quot;/&quot; + item.Name() zipFile = item.Name() + &quot;.cbz&quot; dest := zipDir + &quot;/&quot; + zipFile zipUtils.CompressFile(src, dest) } }} 代码仓库地址 https://github.com/fillpit/Spider","link":"/2021/09/06/Colly-start/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","link":"/tags/Jenkins/"},{"name":"中文显示","slug":"中文显示","link":"/tags/%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA/"},{"name":"语言","slug":"语言","link":"/tags/%E8%AF%AD%E8%A8%80/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"邮件","slug":"邮件","link":"/tags/%E9%82%AE%E4%BB%B6/"},{"name":"软件使用","slug":"软件使用","link":"/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"阿里邮箱","slug":"阿里邮箱","link":"/tags/%E9%98%BF%E9%87%8C%E9%82%AE%E7%AE%B1/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"iPhone","slug":"iPhone","link":"/tags/iPhone/"},{"name":"Spring boot","slug":"Spring-boot","link":"/tags/Spring-boot/"},{"name":"raspberry pi","slug":"raspberry-pi","link":"/tags/raspberry-pi/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"阿里云盘","slug":"阿里云盘","link":"/tags/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/"},{"name":"unraid","slug":"unraid","link":"/tags/unraid/"},{"name":"备份","slug":"备份","link":"/tags/%E5%A4%87%E4%BB%BD/"},{"name":"rclone","slug":"rclone","link":"/tags/rclone/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"Frps","slug":"Frps","link":"/tags/Frps/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"GitHub Actions","slug":"GitHub-Actions","link":"/tags/GitHub-Actions/"},{"name":"Colly","slug":"Colly","link":"/tags/Colly/"},{"name":"golang","slug":"golang","link":"/tags/golang/"}],"categories":[{"name":"折腾","slug":"折腾","link":"/categories/%E6%8A%98%E8%85%BE/"},{"name":"阿里云盘","slug":"折腾/阿里云盘","link":"/categories/%E6%8A%98%E8%85%BE/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/"},{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"},{"name":"运维","slug":"运维","link":"/categories/%E8%BF%90%E7%BB%B4/"},{"name":"效率","slug":"效率","link":"/categories/%E6%95%88%E7%8E%87/"},{"name":"开发环境","slug":"开发环境","link":"/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"爬虫","slug":"折腾/爬虫","link":"/categories/%E6%8A%98%E8%85%BE/%E7%88%AC%E8%99%AB/"}]}